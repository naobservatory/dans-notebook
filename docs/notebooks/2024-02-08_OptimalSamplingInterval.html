<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Dan Rice">
<meta name="dcterms.date" content="2024-02-13">

<title>NAO Cost Estimate MVP – Optimizing the sampling interval</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand navbar-dark ">
      <div class="navbar-container container-fluid">
          <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
</ul>
          <div class="quarto-navbar-tools ms-auto">
</div>
            <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#background" id="toc-background" class="nav-link active" data-scroll-target="#background">Background</a></li>
  <li><a href="#a-two-component-cost-model" id="toc-a-two-component-cost-model" class="nav-link" data-scroll-target="#a-two-component-cost-model">A two-component cost model</a>
  <ul class="collapse">
  <li><a href="#limitations-of-the-two-component-model" id="toc-limitations-of-the-two-component-model" class="nav-link" data-scroll-target="#limitations-of-the-two-component-model">Limitations of the two-component model</a></li>
  </ul></li>
  <li><a href="#optimizing-the-sampling-interval" id="toc-optimizing-the-sampling-interval" class="nav-link" data-scroll-target="#optimizing-the-sampling-interval">Optimizing the sampling interval</a>
  <ul class="collapse">
  <li><a href="#grab-sampling" id="toc-grab-sampling" class="nav-link" data-scroll-target="#grab-sampling">Grab sampling</a></li>
  <li><a href="#continuous-sampling" id="toc-continuous-sampling" class="nav-link" data-scroll-target="#continuous-sampling">Continuous sampling</a></li>
  <li><a href="#windowed-composite-sampling" id="toc-windowed-composite-sampling" class="nav-link" data-scroll-target="#windowed-composite-sampling">Windowed composite sampling</a></li>
  <li><a href="#general-properties" id="toc-general-properties" class="nav-link" data-scroll-target="#general-properties">General properties</a></li>
  </ul></li>
  <li><a href="#a-numerical-example" id="toc-a-numerical-example" class="nav-link" data-scroll-target="#a-numerical-example">A numerical example</a>
  <ul class="collapse">
  <li><a href="#optimal-delta-t" id="toc-optimal-delta-t" class="nav-link" data-scroll-target="#optimal-delta-t">Optimal <span class="math inline">\(\delta t\)</span></a></li>
  <li><a href="#cost-sensitivity-to-delta-t" id="toc-cost-sensitivity-to-delta-t" class="nav-link" data-scroll-target="#cost-sensitivity-to-delta-t">Cost sensitivity to <span class="math inline">\(\delta t\)</span></a></li>
  <li><a href="#sensitivity-of-optimal-delta-t-to-p2ra-factor" id="toc-sensitivity-of-optimal-delta-t-to-p2ra-factor" class="nav-link" data-scroll-target="#sensitivity-of-optimal-delta-t-to-p2ra-factor">Sensitivity of optimal <span class="math inline">\(\delta t\)</span> to P2RA factor</a></li>
  </ul></li>
  <li><a href="#a-second-example-faster-growth-and-longer-delay" id="toc-a-second-example-faster-growth-and-longer-delay" class="nav-link" data-scroll-target="#a-second-example-faster-growth-and-longer-delay">A second example: Faster growth and longer delay</a>
  <ul class="collapse">
  <li><a href="#cost-sensitivity-to-delta-t-1" id="toc-cost-sensitivity-to-delta-t-1" class="nav-link" data-scroll-target="#cost-sensitivity-to-delta-t-1">Cost sensitivity to <span class="math inline">\(\delta t\)</span></a></li>
  <li><a href="#sensitivity-of-optimal-delta-t-to-p2ra-factor-1" id="toc-sensitivity-of-optimal-delta-t-to-p2ra-factor-1" class="nav-link" data-scroll-target="#sensitivity-of-optimal-delta-t-to-p2ra-factor-1">Sensitivity of optimal <span class="math inline">\(\delta t\)</span> to P2RA factor</a></li>
  </ul></li>
  <li><a href="#cost-sensitivity-to-the-latency-t_d" id="toc-cost-sensitivity-to-the-latency-t_d" class="nav-link" data-scroll-target="#cost-sensitivity-to-the-latency-t_d">Cost sensitivity to the latency, <span class="math inline">\(t_d\)</span></a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">NAO Cost Estimate MVP – Optimizing the sampling interval</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Dan Rice </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 13, 2024</p>
    </div>
  </div>
  
    <div>
    <div class="quarto-title-meta-heading">Modified</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">March 31, 2024</p>
    </div>
  </div>
    
  </div>
  

</header>

<section id="background" class="level2">
<h2 class="anchored" data-anchor-id="background">Background</h2>
<p>See <a href="./2024-02-02_CostEstimateMVP.html">previous notebook</a>. The goal of this notebook is to use our simple, deterministic cost estimate to answer the question:</p>
<blockquote class="blockquote">
<p>How often should we process and sequence samples?</p>
</blockquote>
<p>We want to understand the tradeoff between:</p>
<ol type="1">
<li>catching the virus earlier by sampling more frequently, and</li>
<li>saving on processing costs by sampling less frequently.</li>
</ol>
<p>To this end, we posit a two-component cost model:</p>
<ul>
<li>Per-read sequencing costs, and</li>
<li>Per-sample processing costs</li>
</ul>
<p>and find the optimal sampling interval <span class="math inline">\(\delta t\)</span> that minimizes total costs, while sequencing to sufficient depth per sample <span class="math inline">\(n\)</span> to detect a virus by cumulative incidence <span class="math inline">\(\hat{c}\)</span>.</p>
</section>
<section id="a-two-component-cost-model" class="level2">
<h2 class="anchored" data-anchor-id="a-two-component-cost-model">A two-component cost model</h2>
<p>Consider the cost averaged over a long time interval <span class="math inline">\(T\)</span> in which we will take many samples. If we collect and process samples every <span class="math inline">\(\delta t\)</span> days, we will take <span class="math inline">\(T / \delta t\)</span> samples in this interval. If we sample <span class="math inline">\(n\)</span> reads per sample, our total sequencing depth is <span class="math inline">\(n \frac{\delta t}{T}\)</span> reads. Assume that our costs can be divided into a per-sample cost <span class="math inline">\(d_s\)</span> (including costs of collection, transportation, and processing for sequencing) and a per-read cost <span class="math inline">\(d_r\)</span> of sequencing. (Note: the <span class="math inline">\(d\)</span> is sort of awkward because we’ve already used <span class="math inline">\(c\)</span> for “cumulative incidence”. You can think of it as standing for “dollars”.)</p>
<p>We will seek to minimize the total cost of detection: <span class="math display">\[
d_{\text{tot}} = d_s \frac{T}{\delta t} + d_r \frac{nT}{\delta t}.
\]</span> Equivalently, we can divide by the arbitrary time-interval <span class="math inline">\(T\)</span> to get the total rate of spending: <span class="math display">\[
\frac{d_{\text{tot}}}{T} = \frac{d_s}{\delta t} + d_r \frac{n}{\delta t}.
\]</span></p>
<p>In our <a href="https://data.securebio.org/dans-notebook/notebooks/2024-02-02_CostEstimateMVP.html">previous post</a>, we found that the read depth per time required to detect a virus by the time it reaches cumulative incidence <span class="math inline">\(\hat{c}\)</span> is:</p>
<p><span class="math display">\[
\frac{n}{\delta t} = (r + \beta) \left(\frac{\hat{K}}{b \hat{c}}\right) e^{r t_d} f(r \delta t)
\]</span></p>
<p>where the function <span class="math inline">\(f\)</span> depends on the sampling scheme. Substituting this into the rate of spending, we have: <span class="math display">\[
\frac{d_{\text{tot}}}{T} = \frac{d_s}{\delta t} + (r + \beta) \left(\frac{\hat{K}}{b \hat{c}}\right) e^{r t_d} d_r f(r \delta t).
\]</span></p>
<p>In the next section, we will find the value of <span class="math inline">\(\delta t\)</span> that minimizes the rate of spending.</p>
<section id="limitations-of-the-two-component-model" class="level3">
<h3 class="anchored" data-anchor-id="limitations-of-the-two-component-model">Limitations of the two-component model</h3>
<ul>
<li>We assume that we process each sample as it comes in. In practice, we could stockpile a set of <span class="math inline">\(m\)</span> samples and process them simultaneously. This would require splitting out the cost of sampling from the cost of sample prep.</li>
<li>We do not consider the fact that sequencing (and presumably to some extent sample prep) unit costs decrease with greater depth. (I.e., it’s cheaper per-read to do bigger runs.)</li>
<li>We neglect the “batch” effects of sequencing. Typically you buy sequencing in units of “lanes” rather than asking for an arbitrary number of reads. This will introduce threshold effects, where we want to batach our samples to use lanes efficiently.</li>
<li>We do not account for fixed costs that accumulate per unit time regardless of our sampling and sequencing protocols. These do not affect the optimization here, but they do add to the total cost of the system.</li>
</ul>
</section>
</section>
<section id="optimizing-the-sampling-interval" class="level2">
<h2 class="anchored" data-anchor-id="optimizing-the-sampling-interval">Optimizing the sampling interval</h2>
<p>To find the optimal <span class="math inline">\(\delta t\)</span>, we look for a zero of the derivative of spending rate:</p>
<p><span class="math display">\[
\begin{align}
\frac{d}{d \delta t} \frac{d_{\text{tot}}}{T} &amp; = - \frac{d_s}{{\delta t}^2} + (r + \beta) \left(\frac{\hat{K}}{b \hat{c}}\right) e^{r t_d} d_r r f'(r\delta t).
\end{align}
\]</span></p>
<p>Setting the right-hand side equal to zero and rearranging gives:</p>
<p><span class="math display">\[
{(r \delta t)}^2 f'(r \delta t) = \frac{d_s}{d_r} \frac{b \hat{c}}{\hat{K}} \left(\frac{r}{r + \beta}\right) e^{-r t_d}
\]</span></p>
<p>To get any farther, we need to specify <span class="math inline">\(f\)</span> and therefore a sampling scheme. [Note: If we give some general properties of <span class="math inline">\(f\)</span>, we can say some things here that are general to the sampling scheme]</p>
<section id="grab-sampling" class="level3">
<h3 class="anchored" data-anchor-id="grab-sampling">Grab sampling</h3>
<p>We first consider grab sampling, where the entire sample is collected at the sampling time. In that case, we have: <span class="math display">\[
\begin{align}
f(x) &amp; = \frac{e^{-x}{(e^x - 1)}^2}{x^2} \\
     &amp; = 1 + \frac{x^2}{12} + \mathcal{O}(x^3).
\end{align}
\]</span> We are particularly interested in the small-<span class="math inline">\(x\)</span> regime: The depth required becomes exponentially large when <span class="math inline">\(r \delta t \gg 1\)</span>, so it is likely that the optimal interval satisfies <span class="math inline">\(r \delta t \lesssim 1\)</span>. We can check this for self-consistency in any specific numerical examples.</p>
<p>This gives us the derivative: <span class="math display">\[
f'(x) \approx \frac{x}{6}.
\]</span></p>
<p>Using this in our optimization equation yields: <span class="math display">\[
{(r \delta t)}^3 \approx 6 \frac{d_s}{d_r} \frac{b \hat{c}}{\hat{K}} \left(\frac{r}{r + \beta}\right) e^{-r t_d}.
\]</span></p>
</section>
<section id="continuous-sampling" class="level3">
<h3 class="anchored" data-anchor-id="continuous-sampling">Continuous sampling</h3>
<p>In the case of continuous sampling, where the sample taken at time <span class="math inline">\(t\)</span> is a composite sample uniformly collected over the interval <span class="math inline">\([t - \delta t, t)\)</span>, we have: <span class="math display">\[
\begin{align}
f(x) &amp; = \frac{e^x - 1}{x} \\
     &amp; = 1 + \frac{x}{2} + \mathcal{O}(x^2) \\
f'(x) &amp; \approx \frac{1}{2}
\end{align}
\]</span> for small <span class="math inline">\(x\)</span>. Note the difference in functional form from the grab sample case.</p>
<p>Substituting this into the optimization equation yields: <span class="math display">\[
{(r \delta t)}^2 \approx 2 \frac{d_s}{d_r} \frac{b \hat{c}}{\hat{K}} \left(\frac{r}{r + \beta}\right) e^{-r t_d}.
\]</span></p>
</section>
<section id="windowed-composite-sampling" class="level3">
<h3 class="anchored" data-anchor-id="windowed-composite-sampling">Windowed composite sampling</h3>
<p>An intermediate (and more realistic) model of sampling is windowed composite sampling. In this scheme, the sample at time <span class="math inline">\(t\)</span> is a composite sample taken over a window of width <span class="math inline">\(w\)</span> (e.g., 24hours) from <span class="math inline">\(t - w\)</span> to <span class="math inline">\(t\)</span>. Notably, when the sampling interval (<span class="math inline">\(\delta t\)</span>) increases, the length of the window does not. In this case we have:</p>
<p><span class="math display">\[
\begin{align}
f(x) &amp; = \frac{rw}{1 - e^{-rw}} \frac{e^{-x}{(e^x - 1)}^2}{x^2} \\
     &amp; \approx \left(1 + \frac{rw}{2}\right) \frac{e^{-x}{(e^x - 1)}^2}{x^2} \\
     &amp; \approx \left(1 + \frac{rw}{2}\right) + \left(1 + \frac{rw}{2}\right) \left(\frac{x^2}{12}\right) \\
f'(x) &amp; \approx \left(1 + \frac{rw}{2}\right) \left(\frac{x}{6}\right) \\
\end{align}
\]</span> for small <span class="math inline">\(rw\)</span> and <span class="math inline">\(x\)</span>. Note that as <span class="math inline">\(rw \to 0\)</span>, we recover grab sampling.</p>
<p>Since we’re keeping only the leading term in <span class="math inline">\(x = r \delta t\)</span>, and <span class="math inline">\(w \leq \delta t\)</span>, for consistency we should also drop the <span class="math inline">\(\frac{rw}{2}\)</span> (or keep more terms of the expansion). Thus, we’ll treat windowed composite sampling for small windows as equivalent to grab sampling. The key reason for this is that changing the sampling interval does not change the window. Note that for <span class="math inline">\(\delta t \approx w\)</span>, i.e.&nbsp;<span class="math inline">\(x \approx rw\)</span>, <span class="math inline">\(f(x) \approx 1 + \frac{rw}{2}\)</span>, just as with continuous sampling, but <span class="math inline">\(f'(x)\)</span> still behaves like grab sampling.</p>
</section>
<section id="general-properties" class="level3">
<h3 class="anchored" data-anchor-id="general-properties">General properties</h3>
<p>In general, we have: <span class="math display">\[
r \delta t \approx {\left( a\frac{d_s}{d_r} \frac{b \hat{c}}{\hat{K}} \left(\frac{r}{r + \beta}\right) e^{-r t_d} \right)}^{1 / \gamma},
\]</span> where <span class="math inline">\(a\)</span> and <span class="math inline">\(\gamma\)</span> are positive constants that depend on the sampling scheme. We can observe some general features:</p>
<ul>
<li>Faster-growing viruses (higher <span class="math inline">\(r\)</span>) <strong>decreases</strong> the optimal sampling interval.</li>
<li>Increasing the cost per sample <span class="math inline">\(d_s\)</span> <strong>increases</strong> the optimal sampling interval.</li>
<li>Increasing the cost per read <span class="math inline">\(d_r\)</span> <strong>decreases</strong> the optimal sampling interval.</li>
<li>Increasing the P2RA factor <span class="math inline">\(b\)</span> or the target cumulative incidence <span class="math inline">\(c\)</span> <strong>increases</strong> the optimal sampling interval.</li>
<li>Increasing the detection threshold <span class="math inline">\(\hat{K}\)</span> <strong>decreases</strong> the optimal sampling interval.</li>
<li>Increasing the delay between sampling and detection <span class="math inline">\(t_d\)</span> <strong>decreases</strong> the optimal sampling interval.</li>
</ul>
<p>One general trend is: the more optimistic we are about our method (higher <span class="math inline">\(b\)</span>, smaller <span class="math inline">\(\hat{K}\)</span>, shorter <span class="math inline">\(t_d\)</span>), the longer we can wait between samples.</p>
<p>We can also substitute our equation for <span class="math inline">\(n / \delta t\)</span> into this equation, use <span class="math inline">\(f(\delta t) \approx 1\)</span> and rearrange to get: <span class="math display">\[
n d_r \approx \frac{a}{{(r \delta t)}^{\gamma - 1}} d_s.
\]</span> The left-hand side of this equation is the cost spent on sequencing per sample. For continuous sampling, <span class="math inline">\(\gamma = 2\)</span> and for grab sampling and windowed composite, <span class="math inline">\(\gamma = 3\)</span>. Since <span class="math inline">\(r \delta t \ll 1\)</span>, this tells us that we typically should spend more money on sequencing than sample processing.</p>
</section>
</section>
<section id="a-numerical-example" class="level2">
<h2 class="anchored" data-anchor-id="a-numerical-example">A numerical example</h2>
<section id="optimal-delta-t" class="level3">
<h3 class="anchored" data-anchor-id="optimal-delta-t">Optimal <span class="math inline">\(\delta t\)</span></h3>
<div class="cell" data-execution_count="1">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Optional</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> optimal_interval(</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    per_sample_cost: <span class="bu">float</span>,</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    per_read_cost: <span class="bu">float</span>,</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    growth_rate: <span class="bu">float</span>,</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    recovery_rate: <span class="bu">float</span>,</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    read_threshold: <span class="bu">int</span>,</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    p2ra_factor: <span class="bu">float</span>,</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    cumulative_incidence_target: <span class="bu">float</span>,</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    sampling_scheme: <span class="bu">str</span>,</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    delay: <span class="bu">float</span>,</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    composite_window: Optional[<span class="bu">float</span>] <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    constant_term <span class="op">=</span> (</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        (per_sample_cost <span class="op">/</span> per_read_cost)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span> ((p2ra_factor <span class="op">*</span> cumulative_incidence_target) <span class="op">/</span> read_threshold)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span> (growth_rate <span class="op">/</span> (growth_rate <span class="op">+</span> recovery_rate))</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span> np.exp(<span class="op">-</span>growth_rate <span class="op">*</span> delay)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> sampling_scheme <span class="op">==</span> <span class="st">"continuous"</span>:</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> sampling_scheme <span class="op">==</span> <span class="st">"grab"</span>:</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> sampling_scheme <span class="op">==</span> <span class="st">"composite"</span>:</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> composite_window:</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"For composite sampling, must provide a composite_window"</span>)</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> (</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>            <span class="dv">6</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> np.exp(<span class="op">-</span>growth_rate <span class="op">*</span> composite_window))</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>            <span class="op">/</span> (growth_rate <span class="op">*</span> composite_window)</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"sampling_scheme must be continuous or grab"</span>)</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (a <span class="op">*</span> constant_term) <span class="op">**</span> (<span class="dv">1</span> <span class="op">/</span> b) <span class="op">/</span> growth_rate</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>I asked the NAO in <a href="https://twist.com/a/197793/ch/565514/t/5896609/">Twist</a> for info on sequencing and sample-processing costs. Based on their answers, reasonable order-of-magnitude estimate are:</p>
<pre><code>- sample costs: $500 / sample
- sequencing costs: $5K / billion reads</code></pre>
<p>Note that 1 billion reads cost roughly 10x the cost to prepare one sample. As discussed above, our cost model is highly simplified and the specifics of when samples are collected, transported, processed, and batched for sequencing will make this calculation much more complicated in practice.</p>
<p>Let’s use these numbers plus our virus model from the <a href="https://data.securebio.org/dans-notebook/notebooks/2024-02-02_CostEstimateMVP.html#numerical-example">last post</a> to find the optimal sampling interval:</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>d_s <span class="op">=</span> <span class="dv">500</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>d_r <span class="op">=</span> <span class="dv">5000</span> <span class="op">*</span> <span class="fl">1e-9</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Weekly doubling</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> np.log(<span class="dv">2</span>) <span class="op">/</span> <span class="dv">7</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Recovery in two weeks</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> <span class="dv">14</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Detect when 100 cumulative reads</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>k_hat <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Median P2RA factor for SARS-CoV-2 in Rothman</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>ra_i_01 <span class="op">=</span> <span class="fl">1e-7</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert from weekly incidence to prevalence and per 1% to per 1</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> ra_i_01 <span class="op">*</span> <span class="dv">100</span> <span class="op">*</span> (r <span class="op">+</span> beta) <span class="op">*</span> <span class="dv">7</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Goal of detecting by 1% cumulative incidence</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>c_hat <span class="op">=</span> <span class="fl">0.01</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Delay from sampling to detecting of 1 week</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>t_d <span class="op">=</span> <span class="fl">7.0</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>delta_t_grab <span class="op">=</span> optimal_interval(d_s, d_r, r, beta, k_hat, b, c_hat, <span class="st">"grab"</span>, t_d)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>delta_t_cont <span class="op">=</span> optimal_interval(d_s, d_r, r, beta, k_hat, b, c_hat, <span class="st">"continuous"</span>, t_d)</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>delta_t_24hr <span class="op">=</span> optimal_interval(d_s, d_r, r, beta, k_hat, b, c_hat, <span class="st">"composite"</span>, t_d, <span class="dv">1</span>)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Optimal sampling interval with grab sampling:</span><span class="ch">\t\t</span><span class="sc">{</span>delta_t_grab<span class="sc">:.2f}</span><span class="ss"> days"</span>)</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\t</span><span class="ss">r delta_t = </span><span class="sc">{</span>r<span class="op">*</span>delta_t_grab<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Optimal sampling interval with continuous sampling:</span><span class="ch">\t</span><span class="sc">{</span>delta_t_cont<span class="sc">:.2f}</span><span class="ss"> days"</span>)</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\t</span><span class="ss">r delta_t = </span><span class="sc">{</span>r<span class="op">*</span>delta_t_cont<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f"Optimal sampling interval with 24-hour composite sampling:</span><span class="ch">\t</span><span class="sc">{</span>delta_t_24hr<span class="sc">:.2f}</span><span class="ss"> days"</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\t</span><span class="ss">r delta_t = </span><span class="sc">{</span>r<span class="op">*</span>delta_t_24hr<span class="sc">:.2f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Optimal sampling interval with grab sampling:       5.98 days
    r delta_t = 0.59
Optimal sampling interval with continuous sampling: 2.66 days
    r delta_t = 0.26
Optimal sampling interval with 24-hour composite sampling:  5.89 days
    r delta_t = 0.58</code></pre>
</div>
</div>
<p>We should check that <span class="math inline">\(r \delta_t\)</span> is small enough that our approximation for <span class="math inline">\(f(x)\)</span> is accurate:</p>
<div class="cell" data-execution_count="3">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.arange(<span class="fl">0.01</span>, <span class="dv">3</span>, <span class="fl">0.01</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.exp(<span class="op">-</span>x) <span class="op">*</span> ((np.exp(x) <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> x) <span class="op">**</span> <span class="dv">2</span>, label<span class="op">=</span><span class="st">"exact"</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>plt.plot(x, <span class="dv">1</span> <span class="op">+</span> x<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> <span class="dv">12</span>, label<span class="op">=</span><span class="st">"approx"</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>plt.ylim([<span class="dv">0</span>, <span class="dv">2</span>])</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"$x$"</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"$f(x)$"</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Grab/24hr-composite sampling"</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>plt.plot(x, (np.exp(x) <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> x, label<span class="op">=</span><span class="st">"exact"</span>)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>plt.plot(x, <span class="dv">1</span> <span class="op">+</span> x <span class="op">/</span> <span class="dv">2</span>, label<span class="op">=</span><span class="st">"approx"</span>)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>plt.ylim([<span class="dv">0</span>, <span class="dv">5</span>])</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"$x$"</span>)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"$f(x)$"</span>)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Continuous sampling"</span>)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="2024-02-08_OptimalSamplingInterval_files/figure-html/cell-4-output-1.png" width="598" height="449"></p>
</div>
<div class="cell-output cell-output-display">
<p><img src="2024-02-08_OptimalSamplingInterval_files/figure-html/cell-4-output-2.png" width="577" height="449"></p>
</div>
</div>
<p>Looks fine in both cases.</p>
</section>
<section id="cost-sensitivity-to-delta-t" class="level3">
<h3 class="anchored" data-anchor-id="cost-sensitivity-to-delta-t">Cost sensitivity to <span class="math inline">\(\delta t\)</span></h3>
<p>In a real system, we won’t be able to optimize <span class="math inline">\(\delta t\)</span> exactly. Let’s see how the cost varies with the sampling interval (using the exact <span class="math inline">\(f\)</span>):</p>
<div class="cell" data-execution_count="4">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> depth_required(</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    growth_rate: <span class="bu">float</span>,</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    recovery_rate: <span class="bu">float</span>,</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    read_threshold: <span class="bu">int</span>,</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    p2ra_factor: <span class="bu">float</span>,</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    cumulative_incidence_target: <span class="bu">float</span>,</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    sampling_interval: <span class="bu">float</span>,</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    sampling_scheme: <span class="bu">str</span>,</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    delay: <span class="bu">float</span>,</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    composite_window: Optional[<span class="bu">float</span>] <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    leading_term <span class="op">=</span> (</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        (growth_rate <span class="op">+</span> recovery_rate)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span> read_threshold</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">/</span> (p2ra_factor <span class="op">*</span> cumulative_incidence_target)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> growth_rate <span class="op">*</span> sampling_interval</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> sampling_scheme <span class="op">==</span> <span class="st">"continuous"</span>:</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        sampling_term <span class="op">=</span> (np.exp(x) <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> x</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> sampling_scheme <span class="op">==</span> <span class="st">"grab"</span>:</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        sampling_term <span class="op">=</span> np.exp(<span class="op">-</span>x) <span class="op">*</span> ((np.exp(x) <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> x) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> sampling_scheme <span class="op">==</span> <span class="st">"composite"</span>:</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> composite_window:</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"For composite sampling, must provide a composite_window"</span>)</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        rw <span class="op">=</span> growth_rate <span class="op">*</span> composite_window</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        sampling_term <span class="op">=</span> (</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>            (rw <span class="op">/</span> (<span class="dv">1</span> <span class="op">-</span> np.exp(<span class="op">-</span>rw))) <span class="op">*</span> np.exp(<span class="op">-</span>x) <span class="op">*</span> ((np.exp(x) <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> x) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"sampling_scheme must be continuous, grab, or composite"</span>)</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    delay_term <span class="op">=</span> np.exp(growth_rate <span class="op">*</span> delay)</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> leading_term <span class="op">*</span> sampling_term <span class="op">*</span> delay_term</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cost_per_time(</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>    per_sample_cost: <span class="bu">float</span>,</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>    per_read_cost: <span class="bu">float</span>,</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>    sampling_interval: <span class="bu">float</span>,</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>    sample_depth_per_time: <span class="bu">float</span>,</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sample_cost_per_time(per_sample_cost, sampling_interval) <span class="op">+</span> seq_cost_per_time(</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>        per_read_cost, sample_depth_per_time</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sample_cost_per_time(per_sample_cost, sampling_interval):</span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> per_sample_cost <span class="op">/</span> sampling_interval</span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> seq_cost_per_time(per_read_cost, sample_depth_per_time):</span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> per_read_cost <span class="op">*</span> sample_depth_per_time</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="5">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>delta_t <span class="op">=</span> np.arange(<span class="fl">1.0</span>, <span class="dv">21</span>, <span class="dv">1</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>n_cont <span class="op">=</span> depth_required(r, beta, k_hat, b, c_hat, delta_t, <span class="st">"continuous"</span>, t_d)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>n_grab <span class="op">=</span> depth_required(r, beta, k_hat, b, c_hat, delta_t, <span class="st">"grab"</span>, t_d)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>n_24hr <span class="op">=</span> depth_required(</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    r, beta, k_hat, b, c_hat, delta_t, <span class="st">"composite"</span>, t_d, composite_window<span class="op">=</span><span class="fl">1.0</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>cost_cont <span class="op">=</span> cost_per_time(d_s, d_r, delta_t, n_cont)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>cost_grab <span class="op">=</span> cost_per_time(d_s, d_r, delta_t, n_grab)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>cost_24hr <span class="op">=</span> cost_per_time(d_s, d_r, delta_t, n_24hr)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>plt.plot(delta_t, cost_cont, label<span class="op">=</span><span class="st">"continuous"</span>)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>plt.plot(delta_t, cost_grab, label<span class="op">=</span><span class="st">"grab"</span>)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>plt.plot(delta_t, cost_24hr, label<span class="op">=</span><span class="st">"24hr composite"</span>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>plt.ylim([<span class="dv">0</span>, <span class="dv">5000</span>])</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Cost per day"</span>)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r"Sampling interval $\delta t$"</span>)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>plt.legend()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="2024-02-08_OptimalSamplingInterval_files/figure-html/cell-6-output-1.png" width="601" height="436"></p>
</div>
</div>
<p>First, note that the cost of 24hr composite sampling is quite close to grab sampling, and that when the sampling interval is 1 day, it is exactly the same as continuous sampling.</p>
<p>It looks like the cost curve is pretty flat for the grab/24hr sampling, suggesting that we could choose a range of sampling intervals without dramatically increasing the cost. For continuous sampling, the cost increases more steeply with increasing sampling interval.</p>
<p>Finally, let’s break the costs down between sampling and sequencing:</p>
<div class="cell" data-execution_count="6">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>plt.plot(delta_t, cost_grab, label<span class="op">=</span><span class="st">"Total"</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>plt.plot(delta_t, sample_cost_per_time(d_s, delta_t), label<span class="op">=</span><span class="st">"Sampling"</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>plt.plot(delta_t, seq_cost_per_time(d_r, n_grab), label<span class="op">=</span><span class="st">"Sequencing"</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Cost per day"</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r"Sampling interval $\delta t$"</span>)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Grab sampling"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="2024-02-08_OptimalSamplingInterval_files/figure-html/cell-7-output-1.png" width="602" height="451"></p>
</div>
</div>
<p>We can observe a few things:</p>
<ul>
<li>Sequencing costs are always quite a bit higher than sampling costs.</li>
<li>Increasing the sampling interval from one day to about five generates a significant savings in sampling cost, any longer than that gives strongly diminishing returns. (This makes sense from the functional form <span class="math inline">\(d_s / \delta t\)</span>.)</li>
<li>The required sequencing depth increases slowly in this range.</li>
</ul>
</section>
<section id="sensitivity-of-optimal-delta-t-to-p2ra-factor" class="level3">
<h3 class="anchored" data-anchor-id="sensitivity-of-optimal-delta-t-to-p2ra-factor">Sensitivity of optimal <span class="math inline">\(\delta t\)</span> to P2RA factor</h3>
<p>We have a lot of uncertainty in the P2RA factor, even for a specific known virus with a fixed protocol. Let’s see how the optimal sampling interval varies with it. (We’ll only do this for grab sampling.)</p>
<div class="cell" data-execution_count="7">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>ra_i_01 <span class="op">=</span> np.logspace(<span class="op">-</span><span class="dv">9</span>, <span class="op">-</span><span class="dv">6</span>, <span class="dv">100</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert from weekly incidence to prevalence and per 1% to per 1</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> ra_i_01 <span class="op">*</span> <span class="dv">100</span> <span class="op">*</span> (r <span class="op">+</span> beta) <span class="op">*</span> <span class="dv">7</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>delta_t_opt <span class="op">=</span> optimal_interval(d_s, d_r, r, beta, k_hat, b, c_hat, <span class="st">"grab"</span>, t_d)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>plt.semilogx(ra_i_01, delta_t_opt)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"P2RA factor, $RA_i(1\%)$"</span>)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Optimal sampling interval, $\delta t$"</span>)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>plt.ylim([<span class="dv">0</span>, <span class="dv">13</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="2024-02-08_OptimalSamplingInterval_files/figure-html/cell-8-output-1.png" width="587" height="432"></p>
</div>
</div>
<p>As expected, the theory predicts that with higher P2RA factors, we can get away with wider sampling intervals. Also, for this range of P2RA factors, it never recommends daily sampling.</p>
<p>However, we can also see that the cost per day depends much more strongly on the P2RA factor than on optimizing the sampling interval:</p>
<div class="cell" data-execution_count="8">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>delta_t <span class="op">=</span> np.arange(<span class="fl">1.0</span>, <span class="dv">21</span>, <span class="dv">1</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ra_i_01 <span class="kw">in</span> [<span class="fl">1e-8</span>, <span class="fl">1e-7</span>, <span class="fl">1e-6</span>]:</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> ra_i_01 <span class="op">*</span> <span class="dv">100</span> <span class="op">*</span> (r <span class="op">+</span> beta) <span class="op">*</span> <span class="dv">7</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> depth_required(r, beta, k_hat, b, c_hat, delta_t, <span class="st">"grab"</span>, t_d)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    cost <span class="op">=</span> cost_per_time(d_s, d_r, delta_t, n)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    plt.plot(delta_t, cost, label<span class="op">=</span><span class="ss">f"</span><span class="sc">{</span>ra_i_01<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>plt.yscale(<span class="st">"log"</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Cost per day"</span>)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r"Sampling interval $\delta t$"</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>plt.legend(title<span class="op">=</span><span class="vs">r"$RA_i(1\%)$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="2024-02-08_OptimalSamplingInterval_files/figure-html/cell-9-output-1.png" width="591" height="431"></p>
</div>
</div>
</section>
</section>
<section id="a-second-example-faster-growth-and-longer-delay" class="level2">
<h2 class="anchored" data-anchor-id="a-second-example-faster-growth-and-longer-delay">A second example: Faster growth and longer delay</h2>
<p>Let’s consider a more pessimistic scenario: doubling both the growth rate and the delay to detection.</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>d_s <span class="op">=</span> <span class="dv">500</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>d_r <span class="op">=</span> <span class="dv">5000</span> <span class="op">*</span> <span class="fl">1e-9</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Twice-weekly doubling</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> np.log(<span class="dv">2</span>) <span class="op">/</span> <span class="dv">7</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Recovery in two weeks</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> <span class="dv">14</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Detect when 100 cumulative reads</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>k_hat <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Median P2RA factor for SARS-CoV-2 in Rothman</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>ra_i_01 <span class="op">=</span> <span class="fl">1e-7</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert from weekly incidence to prevalence and per 1% to per 1</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> ra_i_01 <span class="op">*</span> <span class="dv">100</span> <span class="op">*</span> (r <span class="op">+</span> beta) <span class="op">*</span> <span class="dv">7</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Goal of detecting by 1% cumulative incidence</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>c_hat <span class="op">=</span> <span class="fl">0.01</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Delay from sampling to detecting of 2 weeks</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>t_d <span class="op">=</span> <span class="fl">14.0</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>delta_t_grab <span class="op">=</span> optimal_interval(d_s, d_r, r, beta, k_hat, b, c_hat, <span class="st">"grab"</span>, t_d)</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>delta_t_cont <span class="op">=</span> optimal_interval(d_s, d_r, r, beta, k_hat, b, c_hat, <span class="st">"continuous"</span>, t_d)</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>delta_t_24hr <span class="op">=</span> optimal_interval(d_s, d_r, r, beta, k_hat, b, c_hat, <span class="st">"composite"</span>, t_d, <span class="dv">1</span>)</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Optimal sampling interval with grab sampling:</span><span class="ch">\t\t</span><span class="sc">{</span>delta_t_grab<span class="sc">:.2f}</span><span class="ss"> days"</span>)</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\t</span><span class="ss">r delta_t = </span><span class="sc">{</span>r<span class="op">*</span>delta_t_grab<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Optimal sampling interval with continuous sampling:</span><span class="ch">\t</span><span class="sc">{</span>delta_t_cont<span class="sc">:.2f}</span><span class="ss"> days"</span>)</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\t</span><span class="ss">r delta_t = </span><span class="sc">{</span>r<span class="op">*</span>delta_t_cont<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f"Optimal sampling interval with 24-hour composite sampling:</span><span class="ch">\t</span><span class="sc">{</span>delta_t_24hr<span class="sc">:.2f}</span><span class="ss"> days"</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\t</span><span class="ss">r delta_t = </span><span class="sc">{</span>r<span class="op">*</span>delta_t_24hr<span class="sc">:.2f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Optimal sampling interval with grab sampling:       1.88 days
    r delta_t = 0.37
Optimal sampling interval with continuous sampling: 0.66 days
    r delta_t = 0.13
Optimal sampling interval with 24-hour composite sampling:  1.82 days
    r delta_t = 0.36</code></pre>
</div>
</div>
<p>We should check that <span class="math inline">\(r \delta_t\)</span> is small enough that our approximation for <span class="math inline">\(f(x)\)</span> is accurate:</p>
<div class="cell" data-execution_count="10">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.arange(<span class="fl">0.01</span>, <span class="dv">3</span>, <span class="fl">0.01</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.exp(<span class="op">-</span>x) <span class="op">*</span> ((np.exp(x) <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> x) <span class="op">**</span> <span class="dv">2</span>, label<span class="op">=</span><span class="st">"exact"</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>plt.plot(x, <span class="dv">1</span> <span class="op">+</span> x<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> <span class="dv">12</span>, label<span class="op">=</span><span class="st">"approx"</span>)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>plt.ylim([<span class="dv">0</span>, <span class="dv">2</span>])</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"$x$"</span>)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"$f(x)$"</span>)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Grab sampling"</span>)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>plt.plot(x, (np.exp(x) <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> x, label<span class="op">=</span><span class="st">"exact"</span>)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>plt.plot(x, <span class="dv">1</span> <span class="op">+</span> x <span class="op">/</span> <span class="dv">2</span>, label<span class="op">=</span><span class="st">"approx"</span>)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>plt.ylim([<span class="dv">0</span>, <span class="dv">5</span>])</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"$x$"</span>)</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"$f(x)$"</span>)</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Continuous sampling"</span>)</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="2024-02-08_OptimalSamplingInterval_files/figure-html/cell-11-output-1.png" width="598" height="449"></p>
</div>
<div class="cell-output cell-output-display">
<p><img src="2024-02-08_OptimalSamplingInterval_files/figure-html/cell-11-output-2.png" width="577" height="449"></p>
</div>
</div>
<p>Looks fine in both cases.</p>
<section id="cost-sensitivity-to-delta-t-1" class="level3">
<h3 class="anchored" data-anchor-id="cost-sensitivity-to-delta-t-1">Cost sensitivity to <span class="math inline">\(\delta t\)</span></h3>
<p>In a real system, we won’t be able to optimize <span class="math inline">\(\delta t\)</span> exactly. Let’s see how the cost varies with the sampling interval:</p>
<div class="cell" data-execution_count="11">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>delta_t <span class="op">=</span> np.arange(<span class="fl">1.0</span>, <span class="dv">21</span>, <span class="dv">1</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>n_cont <span class="op">=</span> depth_required(r, beta, k_hat, b, c_hat, delta_t, <span class="st">"continuous"</span>, t_d)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>n_grab <span class="op">=</span> depth_required(r, beta, k_hat, b, c_hat, delta_t, <span class="st">"grab"</span>, t_d)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>n_24hr <span class="op">=</span> depth_required(</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    r, beta, k_hat, b, c_hat, delta_t, <span class="st">"composite"</span>, t_d, composite_window<span class="op">=</span><span class="fl">1.0</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>cost_cont <span class="op">=</span> cost_per_time(d_s, d_r, delta_t, n_cont)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>cost_grab <span class="op">=</span> cost_per_time(d_s, d_r, delta_t, n_grab)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>cost_24hr <span class="op">=</span> cost_per_time(d_s, d_r, delta_t, n_24hr)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>plt.plot(delta_t, cost_cont, label<span class="op">=</span><span class="st">"continuous"</span>)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>plt.plot(delta_t, cost_grab, label<span class="op">=</span><span class="st">"grab"</span>)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>plt.plot(delta_t, cost_24hr, label<span class="op">=</span><span class="st">"24hr composite"</span>)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>plt.ylim([<span class="dv">0</span>, <span class="dv">100000</span>])</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Cost per day"</span>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r"Sampling interval $\delta t$"</span>)</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>plt.legend()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="2024-02-08_OptimalSamplingInterval_files/figure-html/cell-12-output-1.png" width="618" height="436"></p>
</div>
</div>
<p>It looks like the cost curve is pretty flat for the grab sampling, suggesting that we could choose a range of sampling intervals without dramatically increasing the cost. For continuous sampling, the cost increases more steeply with increasing sampling interval.</p>
<p>Finally, let’s break the costs down between sampling and sequencing:</p>
<div class="cell" data-execution_count="12">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>plt.plot(delta_t, cost_grab, label<span class="op">=</span><span class="st">"Total"</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>plt.plot(delta_t, sample_cost_per_time(d_s, delta_t), label<span class="op">=</span><span class="st">"Sampling"</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>plt.plot(delta_t, seq_cost_per_time(d_r, n_grab), label<span class="op">=</span><span class="st">"Sequencing"</span>)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Cost per day"</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r"Sampling interval $\delta t$"</span>)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Grab sampling"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="2024-02-08_OptimalSamplingInterval_files/figure-html/cell-13-output-1.png" width="610" height="451"></p>
</div>
</div>
<p>In this faster growth + more delay example, sequencing costs completely dwarf sampling costs.</p>
</section>
<section id="sensitivity-of-optimal-delta-t-to-p2ra-factor-1" class="level3">
<h3 class="anchored" data-anchor-id="sensitivity-of-optimal-delta-t-to-p2ra-factor-1">Sensitivity of optimal <span class="math inline">\(\delta t\)</span> to P2RA factor</h3>
<div class="cell" data-execution_count="13">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>ra_i_01 <span class="op">=</span> np.logspace(<span class="op">-</span><span class="dv">9</span>, <span class="op">-</span><span class="dv">6</span>, <span class="dv">100</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert from weekly incidence to prevalence and per 1% to per 1</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> ra_i_01 <span class="op">*</span> <span class="dv">100</span> <span class="op">*</span> (r <span class="op">+</span> beta) <span class="op">*</span> <span class="dv">7</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>delta_t_opt <span class="op">=</span> optimal_interval(d_s, d_r, r, beta, k_hat, b, c_hat, <span class="st">"grab"</span>, t_d)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>plt.semilogx(ra_i_01, delta_t_opt)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"P2RA factor, $RA_i(1\%)$"</span>)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Optimal sampling interval, $\delta t$"</span>)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>plt.ylim([<span class="dv">0</span>, <span class="dv">5</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="2024-02-08_OptimalSamplingInterval_files/figure-html/cell-14-output-1.png" width="578" height="437"></p>
</div>
</div>
<p>In this case, daily sampling is sometimes favored when the P2RA factor is small enough.</p>
<p>However, we can also see that the cost per day depends much more strongly on the P2RA factor than on optimizing the sampling interval:</p>
<div class="cell" data-execution_count="14">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>delta_t <span class="op">=</span> np.arange(<span class="fl">1.0</span>, <span class="dv">21</span>, <span class="dv">1</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ra_i_01 <span class="kw">in</span> [<span class="fl">1e-8</span>, <span class="fl">1e-7</span>, <span class="fl">1e-6</span>]:</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> ra_i_01 <span class="op">*</span> <span class="dv">100</span> <span class="op">*</span> (r <span class="op">+</span> beta) <span class="op">*</span> <span class="dv">7</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> depth_required(r, beta, k_hat, b, c_hat, delta_t, <span class="st">"grab"</span>, t_d)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    cost <span class="op">=</span> cost_per_time(d_s, d_r, delta_t, n)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    plt.plot(delta_t, cost, label<span class="op">=</span><span class="ss">f"</span><span class="sc">{</span>ra_i_01<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>plt.yscale(<span class="st">"log"</span>)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Cost per day"</span>)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r"Sampling interval $\delta t$"</span>)</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>plt.legend(title<span class="op">=</span><span class="vs">r"$RA_i(1\%)$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="2024-02-08_OptimalSamplingInterval_files/figure-html/cell-15-output-1.png" width="591" height="431"></p>
</div>
</div>
</section>
</section>
<section id="cost-sensitivity-to-the-latency-t_d" class="level2">
<h2 class="anchored" data-anchor-id="cost-sensitivity-to-the-latency-t_d">Cost sensitivity to the latency, <span class="math inline">\(t_d\)</span></h2>
<p>As a final application, let’s calculate what the optimal cost would be as a function of delay/latency time <span class="math inline">\(t_d\)</span>. We’ll use 24-hr composite sampling. And for some realism, we’ll round the optimal sampling interval to the nearest day.</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>d_s <span class="op">=</span> <span class="dv">500</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>d_r <span class="op">=</span> <span class="dv">5000</span> <span class="op">*</span> <span class="fl">1e-9</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Bi-weekly doubling</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> np.log(<span class="dv">2</span>) <span class="op">/</span> <span class="dv">7</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Recovery in two weeks</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> <span class="dv">14</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Detect when 100 cumulative reads</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>k_hat <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Median P2RA factor for SARS-CoV-2 in Rothman</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>ra_i_01 <span class="op">=</span> <span class="fl">1e-7</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert from weekly incidence to prevalence and per 1% to per 1</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> ra_i_01 <span class="op">*</span> <span class="dv">100</span> <span class="op">*</span> (r <span class="op">+</span> beta) <span class="op">*</span> <span class="dv">7</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Goal of detecting by 1% cumulative incidence</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>c_hat <span class="op">=</span> <span class="fl">0.01</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="16">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>t_d <span class="op">=</span> np.arange(<span class="fl">1.0</span>, <span class="fl">22.0</span>, <span class="fl">1.0</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>delta_t_opt <span class="op">=</span> optimal_interval(</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    d_s, d_r, r, beta, k_hat, b, c_hat, <span class="st">"composite"</span>, t_d, <span class="fl">1.0</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>delta_t_round <span class="op">=</span> np.<span class="bu">round</span>(delta_t_opt)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> depth_required(r, beta, k_hat, b, c_hat, delta_t_round, <span class="st">"composite"</span>, t_d, <span class="fl">1.0</span>)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>cost <span class="op">=</span> cost_per_time(d_s, d_r, delta_t_round, n)</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>plt.plot(t_d, delta_t_round, <span class="st">"o"</span>)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>plt.ylim([<span class="dv">0</span>, <span class="dv">5</span>])</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r"Latency $t_d$ (days)"</span>)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="vs">r"Optimal sampling interval $\delta t$ (days)"</span>)</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="2024-02-08_OptimalSamplingInterval_files/figure-html/cell-17-output-1.png" width="578" height="436"></p>
</div>
</div>
<p>Shorter latency means that we can sample less often.</p>
<div class="cell" data-execution_count="17">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>plt.plot(t_d, n, <span class="st">"o"</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r"Latency $t_d$ (days)"</span>)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Depth per day (reads)"</span>)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="2024-02-08_OptimalSamplingInterval_files/figure-html/cell-18-output-1.png" width="589" height="445"></p>
</div>
</div>
<p>Longer latency means that we have to sequence exponentially more reads per day. This leads to exponentially higher costs:</p>
<div class="cell" data-execution_count="18">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>plt.plot(t_d, cost, <span class="st">"o"</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r"Latency $t_d$ (days)"</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Cost per day (dollars)"</span>)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="2024-02-08_OptimalSamplingInterval_files/figure-html/cell-19-output-1.png" width="610" height="431"></p>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>